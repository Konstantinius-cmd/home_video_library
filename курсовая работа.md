<p align="center">Министерство образования, науки и молодежной политики Республики Коми</p>

<p align="center">ГПОУ "Сыктывкарский политехнический техникум"</p>






<p align="center">Курсовая работа</p>



<p align="center">Тема: База данных для домашней видеотеки</p>















<p align="right"> выполнил </p>

<p align="right">студент 4 курса </p>

<p align="right">414 группы </p>

<p align="right">Устюжов Константин Андреевич</p>



<p align="right">проверил</p>

<p align="right">Пунгин И.В.</p>

<p align="right">дата проверки: ______________</p>










<p align="center">Сыктывкар, 2025</p>






# Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы:База данных Издательства. Подсистема служба маркетинга

Срок представления работы к защите: <ins> ... марта 2025 года. </ins>

Перечень подлежащих разработке вопросов:

1. Анализ предметной области. Постановка задачи.

    1.1. Описание предметной области и функции решаемых задач.

    1.2. Перечень входных данных.

    1.3. Перечень выходных данных

    1.4. Ограничения предметной области (если таковые имеются).

    1.5. Взаимодействие с другими программами.

3. Инфологическая (концептуальная) модель базы данных.

    2.1. Выделение информационных объектов.

    2.2. Определение атрибутов объектов.

    2.3. Определение отношений и мощности отношений между объектами.

    2.4. Построение концептуальной модели.

4. Логическая структура БД.

5. Физическая структура базы данных.

6. Реализация проекта в среде конкретной СУБД.

    6.1. Создание таблиц и индексов.

    6.2. Создание представлений и функций.

    5.3. Разработка интерфейса.

    5.4. Назначение прав доступа.

    5.5. Разработка стратегии резервного копирования базы данных.


Руководитель работы __________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _______________________________ <ins> В. А. Попов </ins>




## <a id="content">Содержание</a>

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)
5. [Приложения](#applications)



**Введение**  

В условиях роста объемов цифрового медиаконтента и многообразия его источников эффективное управление домашней видеотекой становится ключевой задачей для систематизации личной коллекции. Автоматизация учета видеофайлов, отслеживания их происхождения, статуса хранения и истории взаимодействия требует разработки специализированной базы данных (БД). Такая система должна централизованно хранить метаданные о медиафайлах, информацию об их источниках (например, стриминговые платформы, физические носители), а также фиксировать события, связанные с добавлением, просмотром или архивированием контента.  

Внедрение автоматизированной БД обеспечит:  
- **Упрощение каталогизации** за счет структурированного хранения данных о видео (название, автор, год, длительность).  
- **Контроль источников контента** — отслеживание происхождения файлов (YouTube, DVD, торренты) для последующего лицензионного аудита.  
- **Управление статусами** — фиксация текущего состояния видео («в коллекции», «архивировано», «удалено»).  
- **Анализ активности** — формирование отчетов на основе событий (дата добавления, частота просмотров, перемещение файлов).  

Ключевая задача проекта — создание системы, объединяющей данные о видеофайлах, их источниках и событиях, с функциями:  
- Автоматической привязки медиафайлов к источникам (например, ссылкам на стриминговые сервисы).  
- Фиксации изменений статусов (например, переход из «на просмотре» в «архив»).  
- Формирования аналитики по длительности контента, динамике пополнения коллекции и типам источников.  
- Защиты целостности данных через проверку корректности метаданных (год выпуска, формат файла).  

Разработанная система станет инструментом для:  
- Оптимизации хранения коллекции за счет анализа статусов и физического расположения файлов.  
- Упрощения поиска медиа по метаданным (автор, жанр, источник).  
- Поддержки принятия решений о пополнении коллекции на основе статистики просмотров.  

Курсовая работа направлена на создание базы данных, которая не только автоматизирует учет домашней видеотеки, но и станет основой для интеграции с медиаплеерами, анализа трендов потребления контента и минимизации дублирования файлов.


## <a id="target">Цель работы</a>  


**Целью курсовой работы** является разработка базы данных для домашней видеотеки, обеспечивающей автоматизацию процессов каталогизации медиафайлов, отслеживания их источников, управления статусами и анализа истории взаимодействия с контентом. В рамках работы предполагается:  

1. **Создание структуры базы данных**:  
   Разработать схему БД, отражающую ключевые сущности видеотеки:  
   - **Видео** (название, автор, год, длительность, путь к файлу).  
   - **Источники** (название, ссылка или физический носитель).  
   - **События** (тип события: добавление, просмотр, архивирование, удаление).  
   - **Статус** (текущее состояние видео: в коллекции, на просмотре, удалено).  
   Обеспечить целостность данных через:  
   - Нормализацию таблиц.  
   - Установку связей (например, привязка видео к источнику).  
   - Ограничения (проверка корректности дат, допустимых значений статусов).  

2. **Реализация функционала для управления коллекцией**:  
   Создать механизмы для:  
   - Добавления новых видео с автоматической привязкой к источникам (YouTube, DVD, торренты).  
   - Обновления статусов видео (например, переход из «в коллекции» в «архив»).  
   - Фиксации событий (дата добавления, последний просмотр, удаление).  

3. **Разработка аналитических инструментов**:  
   Реализовать представления и запросы для:  
   - Анализа популярности контента по количеству просмотров и длительности.  
   - Формирования отчетов по динамике пополнения коллекции и типам источников.  
   - Прогнозирования потребности в дисковом пространстве на основе объема добавляемых видео.  

4. **Обеспечение безопасности данных**:  
   Внедрить механизмы защиты:  
   - Шифрование конфиденциальных полей (например, пути к файлам).  
   - Аудит изменений статусов и событий через журнал изменений.  
   - Резервное копирование данных для предотвращения потерь.  

5. **Интеграция с внешними сервисами**:  
   Настроить взаимодействие с:  
   - Медиаплеерами для автоматической записи событий просмотра.  
   - Стриминговыми платформами для синхронизации метаданных (например, обновление названий и авторов).  

6. **Документирование системы**:  
   Подготовить:  
   - Техническую документацию (ER-диаграммы, описание связей между таблицами).  
   - Руководство по использованию (поиск видео по источнику, фильтрация по статусу).  
   - API-документацию для интеграции с медиаприложениями.  

**Итоговая цель** — создание системы, которая не только автоматизирует учет медиаконтента, но и станет основой для:  
- Оптимизации хранения файлов за счет анализа статусов и объема коллекции.  
- Упрощения навигации по видеотеке через фильтры (источник, год, автор).  
- Внедрения интеллектуальных решений, таких как анализ трендов потребления контента.  

Таким образом, разработанная база данных позволит эффективно управлять домашней видеотекой, минимизировать дублирование контента и упростить доступ к медиафайлам.


### Анализ предметной области и постановка задачи  

#### 1. **Описание предметной области и функции решаемых задач**  
   - **Предметная область** данной работы — управление домашней видеотекой, включая каталогизацию медиафайлов, отслеживание их источников, управление статусами и анализ истории взаимодействия с контентом. Система направлена на автоматизацию процессов учета видеофайлов, что позволит оптимизировать хранение коллекции, минимизировать дублирование контента и упростить доступ к медиафайлам. Основная цель — повышение удобства управления видеотекой за счет точного учета данных о файлах, анализа их происхождения и оперативного обновления статусов.  

   - **Функции решаемых задач:**  
     - **Управление видеотекой:**  
       - Добавление новых видео с автоматической привязкой к источникам (YouTube, DVD, торренты).  
       - Обновление статусов видео (например, переход из «в коллекции» в «архив»).  
       - Фиксация событий (дата добавления, последний просмотр, удаление).  

     - **Анализ эффективности использования видеотеки:**  
       - Расчет метрик: частота просмотров, популярность контента по длительности и жанрам.  
       - Формирование отчетов по динамике пополнения коллекции и типам источников.  

     - **Отслеживание источников контента:**  
       - Учет информации об источниках (название, ссылка или физический носитель).  
       - Привязка видеофайлов к конкретным источникам для последующего лицензионного аудита.  

     - **Управление статусами видео:**  
       - Контроль текущего состояния видео («в коллекции», «на просмотре», «удалено»).  
       - Автоматическое обновление статусов при совершении событий (например, перемещение в архив).  

     - **Контроль объема хранимых данных:**  
       - Мониторинг занимаемого дискового пространства.  
       - Прогнозирование потребности в дополнительном пространстве на основе объема добавляемых видео.  



### 2. **Постановка задачи**  
Разработать базу данных и приложение, которые:  
- Автоматизируют учёт видеотеки, включая каталогизацию видеофайлов, отслеживание их источников, управление статусами и фиксацию событий.  
- Обеспечивают целостность данных через:  
  - Уникальность идентификаторов видео, источников, событий и статусов.  
  - Проверку корректности дат (например, дата добавления не может быть позже текущей даты).  
  - Контроль допустимых значений для статусов и типов событий.  
- Предоставляют инструменты для:  
  - Анализа популярности контента на основе количества просмотров и длительности видео.  
  - Формирования отчётов по динамике пополнения коллекции и типам источников.  
  - Прогнозирования потребности в дисковом пространстве на основе объёмов добавляемых файлов.  
- Интегрируются с внешними системами:  
  - Синхронизация с медиаплеерами для автоматической записи событий просмотра.  
  - Взаимодействие со стриминговыми платформами для обновления метаданных (например, авторов и названий).  
- Поддерживают безопасность данных:  
  - Шифрование путей к файлам для защиты от несанкционированного доступа.  
  - Аудит изменений статусов и событий через журнал действий.  

**Пример реализации:**  
- Таблица `Видео` хранит данные о медиафайлах, включая название, автора, год, длительность, привязку к источнику и путь к файлу.  
- Таблица `Источники` содержит информацию о происхождении контента (например, YouTube, DVD, торренты).  
- Таблица `События` фиксирует действия с видеофайлами (добавление, просмотр, архивирование) с указанием типа события и даты.  
- Таблица `Статус` отражает текущее состояние видео (например, "в коллекции", "на просмотре", "архивировано").  
- Триггеры автоматически обновляют статусы видео при совершении определённых событий (например, переход из "в коллекции" в "архив").  
- Представление `video_statistics` агрегирует данные о популярности контента (количество просмотров, средняя длительность).  
- Интерфейс позволяет фильтровать видео по источникам, статусам и авторам, а также анализировать историю событий.  




## <a id="input">2. Перечень входных данных</a>  
### **Перечень входных данных для домашней видеотеки**  

Для корректной работы системы управления домашней видеотекой требуются следующие входные данные:  

---

### **Данные о видеофайлах:**  
  - Идентификатор видео (ID).  
  - Название видео.  
  - Автор или режиссер.  
  - Год выпуска.  
  - Длительность (в секундах).  
  - Идентификатор источника (внешний ключ к таблице `Источники`).  
  - Путь к файлу (локальный или сетевой путь).  

---

### **Данные об источниках:**  
  - Идентификатор источника (ID).  
  - Название источника (например, "YouTube", "DVD", "Torrent").  
  - Ссылка на источник (если применимо).  

---

### **Данные о событиях:**  
  - Идентификатор события (ID).  
  - Тип события ("Добавлено", "Просмотрено", "Пересмотрено", "Удалено", "Архивировано", "Перемещено").  
  - Дата и время события.  
  - Примечание (например, "Скачано с YouTube" или "Перенесено в папку 'Архив'").  
  - Идентификатор видео (внешний ключ к таблице `Видео`).  

---

  

---

### **Данные для аналитики:**  
  - Ключевые метрики использования:  
    - Частота просмотров (количество просмотров за период).  
    - Популярность контента по длительности (средняя длительность просмотра).  
    - Динамика пополнения коллекции (количество добавленных видео за период).  
  - Периодичность отчетов (ежедневно, еженедельно, ежемесячно).  
  - Пороговые значения для уведомлений (например, "Видео не просмотрено более года").  

---



### <a id="output">3. Перечень выходных данных для домашней видеотеки</a>  
На основе входных данных система предоставляет следующие выходные данные:  

---

#### **1. Отчёты по использованию видеотеки:**  
- **Анализ популярности контента:**  
  - Частота просмотров для каждого видео.  
  - Топ видео с наибольшим количеством просмотров.  
- **Статистика длительности просмотров:**  
  - Средняя длительность просмотра для каждого видео.  
  - Процент завершённых просмотров (сколько раз видео было просмотрено до конца).  
- **Динамика добавления видео:**  
  - Количество добавленных видео за определённый период.  
  - Анализ источников контента (например, YouTube, DVD, торренты).  

---

#### **2. Статистика по статусам видео:**  
- **Распределение видео по статусам:**  
  - Количество видео в каждом статусе ("в коллекции", "на просмотре", "архивировано" и т.д.).  
  - Доля видео, которые были удалены или повреждены.  
- **История изменений статусов:**  
  - Отчёт о том, как часто видео перемещаются между статусами (например, из "в коллекции" в "архив").  

---

#### **3. Отчёты по источникам контента:**  
- **Популярность источников:**  
  - Количество видео, добавленных из каждого источника (YouTube, DVD, торренты и т.д.).  
  - Сравнение использования физических носителей и цифровых платформ.  
- **Эффективность источников:**  
  - Анализ того, какие источники предоставляют наиболее популярный контент.  

---

#### **4. Прогнозы и аналитика хранения:**  
- **Прогнозирование потребности в дисковом пространстве:**  
  - Оценка будущего объёма хранимых видео на основе текущих трендов добавления контента.  
  - Рекомендации по освобождению места (например, архивирование редко используемых видео).  
- **Анализ использования дискового пространства:**  
  - Общий объём занимаемого пространства.  
  - Распределение пространства по статусам видео (например, сколько занимают архивированные файлы).  

---

#### **5. История событий:**  
- **Лог действий с видеофайлами:**  
  - Отчёт о всех событиях (добавление, просмотр, удаление, архивирование) за определённый период.  
  - Анализ активности пользователей (если в системе предусмотрена авторизация).  
- **Частота событий:**  
  - Количество событий каждого типа (например, сколько раз видео было пересмотрено).  

---



### <a id="limitations">4. Ограничения предметной области для домашней видеотеки</a>  
При работе с системой управления домашней видеотекой необходимо учитывать следующие ограничения:  

1. **Ограничение по объёму данных:**  
   - Рост количества видеофайлов, событий и источников может замедлить выполнение аналитических запросов. Для решения требуется:  
     - Партиционирование таблиц (например, по датам добавления видео).  
     - Использование индексов для ускорения поиска и фильтрации данных.  


2. **Ограничение по обновлению данных:**  
   - Для предотвращения потерь настроить:  
     - Ежедневное резервное копирование с хранением копий в облаке.  
     - Триггеры для аудита изменений (например, журнал событий в таблице `События`).  

---

### <a id="integration">5. Взаимодействие с другими программами для домашней видеотеки</a>  
Система интегрируется с внешними сервисами для расширения функциональности:  

1. **Медиаплееры (VLC, Plex):**  
   - Синхронизация данных о просмотрах для автоматической записи событий.  
   - Обновление статусов видео (например, "Просмотрено") после завершения воспроизведения.  

2. **Стриминговые платформы (YouTube, Vimeo):**  
   - Автоматическое обновление метаданных (например, авторов и названий) через API.  
   - Загрузка новых видеофайлов из плейлистов или каналов.  

3. **Файловые хранилища (Google Drive, Dropbox):**  
   - Синхронизация путей к файлам для обеспечения доступа к видеофайлам из облака.  
   - Автоматическое добавление новых файлов из облачных папок.  

4. **Инструменты аналитики (Power BI, Tableau):**  
   - Визуализация популярности контента, статистики просмотров и динамики пополнения коллекции.  
   - Создание дашбордов для анализа использования видеотеки.  

5. **Системы прогнозирования потребностей (на основе ML):**  
   - Прогнозирование потребности в дисковом пространстве на основе исторических данных о добавлении видео.  
   - Рекомендации по архивированию или удалению редко используемых файлов.  

---




## <a id="infological_model">Инфологическая (концептуальная) модель базы данных</a>  

### 1. **Выделение информационных объектов**

---

#### **1. Видео (`Видео`)**
- Основной объект, представляющий видеофайлы в коллекции.
- Атрибуты:
  - `id_видео` — уникальный идентификатор видео (UUID).
  - `название` — название видео.
  - `автор` — автор или режиссер видео.
  - `год` — год выпуска видео.
  - `длительность` — длительность видео в секундах.
  - `источник_id` — ссылка на источник видео (внешний ключ к таблице `Источники`).
  - `файл_путь` — путь к файлу на локальном или сетевом хранилище.

---

#### **2. Источники (`Источники`)**
- Объект, описывающий источники, из которых были получены видеофайлы.
- Атрибуты:
  - `id_источника` — уникальный идентификатор источника (UUID).
  - `название` — название источника (например, YouTube, DVD, Netflix).
  - `ссылка` — URL или другая информация об источнике (если применимо).

---

#### **3. События (`События`)**
- Объект, фиксирующий действия, связанные с видеофайлами (добавление, просмотр, удаление и т.д.).
- Атрибуты:
  - `id_события` — уникальный идентификатор события (UUID).
  - `тип_события` — тип события (например, "Добавлено", "Просмотрено", "Удалено").
  - `дата` — дата и время события.
  - `примечание` — дополнительная информация о событии.
  - `видео_id` — ссылка на видеофайл, с которым связано событие (внешний ключ к таблице `Видео`).

---

#### **4. Статусы (`Статус`)**
- Объект, отражающий текущий статус видеофайла (например, "В коллекции", "Просмотрено", "Архивировано").
- Атрибуты:
  - `id_статуса` — уникальный идентификатор статуса (UUID).
  - `статус` — текущий статус видеофайла.
  - `видео_id` — ссылка на видеофайл, к которому относится статус (внешний ключ к таблице `Видео`).

---

### Обоснование выбора объектов
1. **Видео** — основной объект системы, вокруг которого строится вся функциональность. Каждое видео имеет уникальные характеристики (название, автор, длительность) и связано с источником происхождения.
2. **Источники** — важный объект для отслеживания происхождения видеофайлов. Позволяет анализировать, какие источники наиболее популярны.
3. **События** — обеспечивают историю взаимодействия с видеофайлами, что полезно для анализа поведения пользователя (например, частота просмотров или удалений).
4. **Статусы** — позволяют управлять текущим состоянием видеофайлов, что важно для организации коллекции (например, архивирование редко используемых файлов).

---

### Пример связи между объектами
- **Видео → Источники:**  
  Одно видео может быть получено из одного источника (`1:1`).  
  Связь: `Видео.источник_id` → `Источники.id_источника`.

- **Видео → События:**  
  Одно видео может иметь много событий (`1:N`).  
  Связь: `Видео.id_видео` → `События.видео_id`.

- **Видео → Статусы:**  
  Одно видео может иметь один статус (`1:1`).  
  Связь: `Видео.id_видео` → `Статусы.видео_id`.

---

Эти объекты формируют основу для построения концептуальной модели базы данных, которая будет детализирована в следующих шагах.

### 4. **ER-диаграмма**  
![ER-диаграмма](![image](https://github.com/user-attachments/assets/2c8c4407-037f-42b0-b22e-25a2caa6df9e)

*Рисунок 1. Концептуальная модель для подсистемы маркетинга издательства.*  

---

### 5. **Ограничения целостности**  
- **Уникальность:**  
  - `users.username` — уникальный логин.  
  - `customers.email` — уникальный email клиента.  
- **Проверка значений:**  
  - `books.stock` не может быть отрицательным.  
  - `campaigns.end_date` не раньше `start_date`.  
- **Каскадное удаление:**  
  - Удаление кампании → удаление связанных материалов.  
  - Удаление автора → обнуление `author_id` в таблице `books`.  

---


## <a id="logical_structure">Логическая структура базы данных</a>  

Логическая структура базы данных для подсистемы маркетинга издательства включает следующие таблицы с атрибутами, типами данных, ключами и ограничениями:  

https://github.com/Konstantinius-cmd/home_video_library/blob/b6892a7aee5340bcaa554f2cff87ca547591020c/database.png


---

### **Таблица `users` (Пользователи)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `user_id`           | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `username`          | VARCHAR(50)     | Логин                            | UNIQUE, NOT NULL                |  
| `password_hash`     | VARCHAR(255)    | Хеш пароля                       | NOT NULL                        |  
| `role`              | VARCHAR(20)     | Роль: admin, marketer, customer  | CHECK (`role` IN ('admin', 'marketer', 'customer')) |  

---

### **Таблица `administrators` (Администраторы)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `admin_id`          | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `user_id`           | INTEGER         | Ссылка на пользователя           | FOREIGN KEY REFERENCES `users`  |  
| `access_level`      | VARCHAR(50)     | Уровень доступа                  | DEFAULT 'full'                  |  

---

### **Таблица `marketers` (Маркетологи)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `marketer_id`       | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `user_id`           | INTEGER         | Ссылка на пользователя           | FOREIGN KEY REFERENCES `users`  |  
| `department`        | VARCHAR(100)    | Отдел (Digital, SMM, SEO)        | NOT NULL                        |  

---

### **Таблица `customers` (Клиенты)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `customer_id`       | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `email`             | VARCHAR(255)    | Email                            | UNIQUE, NOT NULL                |  
| `phone`             | VARCHAR(20)     | Телефон                          |                                 |  
| `preferred_genres`  | TEXT[]          | Любимые жанры книг               |                                 |  

---

### **Таблица `authors` (Авторы)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `author_id`         | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `first_name`        | VARCHAR(100)    | Имя автора                       | NOT NULL                        |  
| `last_name`         | VARCHAR(100)    | Фамилия автора                   | NOT NULL                        |  
| `bio`               | TEXT            | Биография                        |                                 |  

---

### **Таблица `books` (Книги)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `book_id`           | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `title`             | VARCHAR(255)    | Название книги                   | NOT NULL                        |  
| `genre`             | VARCHAR(100)    | Жанр                             | NOT NULL                        |  
| `price`             | NUMERIC(10,2)   | Цена                             | CHECK (`price` > 0)            |  
| `stock`             | INTEGER         | Остаток на складе                | CHECK (`stock` >= 0)           |  
| `author_id`         | INTEGER         | Автор книги                      | FOREIGN KEY REFERENCES `authors` |  

---

### **Таблица `campaigns` (Кампании)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `campaign_id`       | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `campaign_name`     | VARCHAR(255)    | Название кампании                | UNIQUE, NOT NULL                |  
| `start_date`        | DATE            | Дата начала                      | NOT NULL                        |  
| `end_date`          | DATE            | Дата окончания                   | CHECK (`end_date` >= `start_date`) |  
| `budget`            | NUMERIC(12,2)   | Бюджет                          | CHECK (`budget` >= 0)          |  
| `marketer_id`       | INTEGER         | Ответственный маркетолог         | FOREIGN KEY REFERENCES `marketers` |  

---

### **Таблица `marketing_materials` (Маркетинговые материалы)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `material_id`       | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `type`              | VARCHAR(50)     | Тип (баннер, email, видео)       | NOT NULL                        |  
| `content`           | TEXT            | Ссылка или текст контента        | NOT NULL                        |  
| `campaign_id`       | INTEGER         | Привязка к кампании              | FOREIGN KEY REFERENCES `campaigns` |  
| `creation_date`     | TIMESTAMP       | Дата создания                    | DEFAULT CURRENT_TIMESTAMP       |  

---

### **Таблица `orders` (Заказы)**  
| Атрибут            | Тип данных       | Описание                          | Ограничения                     |  
|---------------------|------------------|-----------------------------------|---------------------------------|  
| `order_id`          | SERIAL          | Уникальный идентификатор         | PRIMARY KEY                     |  
| `customer_id`       | INTEGER         | Клиент                           | FOREIGN KEY REFERENCES `customers` |  
| `book_id`           | INTEGER         | Книга                            | FOREIGN KEY REFERENCES `books` |  
| `quantity`          | INTEGER         | Количество                       | CHECK (`quantity` > 0)         |  
| `order_date`        | TIMESTAMP       | Дата заказа                      | DEFAULT CURRENT_TIMESTAMP       |  
| `total_price`       | NUMERIC(10,2)   | Сумма заказа                     | CHECK (`total_price` > 0)      |  

---

### **Связи между таблицами**  
1. **`users` → `administrators` и `marketers`:**  
   - `administrators.user_id` → `users.user_id` (1:1).  
   - `marketers.user_id` → `users.user_id` (1:1).  

2. **`campaigns` → `marketing_materials`:**  
   - `campaigns.campaign_id` → `marketing_materials.campaign_id` (1:N).  

3. **`campaigns` → `marketers`:**  
   - `marketers.marketer_id` → `campaigns.marketer_id` (1:N).  

4. **`books` → `authors`:**  
   - `authors.author_id` → `books.author_id` (1:N).  

5. **`orders` → `customers` и `books`:**  
   - `customers.customer_id` → `orders.customer_id` (1:N).  
   - `books.book_id` → `orders.book_id` (1:N).  

---

### **Индексы для оптимизации**  
```sql  
-- Для ускорения поиска кампаний по названию  
CREATE INDEX idx_campaign_name ON campaigns (campaign_name);  

-- Для анализа продаж по дате заказа  
CREATE INDEX idx_order_date ON orders (order_date);  

-- Для фильтрации книг по жанру  
CREATE INDEX idx_book_genre ON books (genre);  
```  


## <a id="physical_structure">Физическая структура базы данных</a>  

Физическая структура базы данных определяет способы хранения данных, оптимизацию производительности и обеспечение целостности в PostgreSQL. Ниже приведены ключевые аспекты реализации.  

---

### **1. Выбор типов данных**  
Типы данных выбраны с учётом требований к точности, объёму памяти и производительности:  

#### **Таблица `books`**  
| Поле          | Тип данных       | Обоснование                                   |  
|---------------|------------------|-----------------------------------------------|  
| `price`       | NUMERIC(10,2)    | Точность финансовых расчётов (2 знака после запятой). |  
| `stock`       | INTEGER          | Целочисленный остаток с проверкой `CHECK (stock >= 0)`. |  

#### **Таблица `campaigns`**  
| Поле          | Тип данных       | Обоснование                                   |  
|---------------|------------------|-----------------------------------------------|  
| `budget`      | NUMERIC(12,2)    | Поддержка крупных бюджетов (до 99 999 999.99). |  
| `start_date`  | DATE             | Формат "ГГГГ-ММ-ДД" для работы с датами.      |  

#### **Таблица `users`**  
| Поле            | Тип данных       | Обоснование                                   |  
|-----------------|------------------|-----------------------------------------------|  
| `password_hash` | VARCHAR(255)     | Хранение хешей паролей.    |  

---



## <a id="physical_structure">Физическая структура базы данных</a>  
### **2. Оптимизация индексов**  

Индексы — ключевой инструмент для ускорения выполнения запросов, особенно при работе с большими объёмами данных. В маркетинговой подсистеме индексы создаются для полей, которые:  
- Участвуют в условиях `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.  
- Часто используются для фильтрации или сортировки.  

---

#### **Автоматически индексируемые поля**  
- **Первичные ключи** (`campaign_id`, `material_id`, `book_id` и др.) индексируются по умолчанию, что обеспечивает быстрый доступ к записям.  

---

#### **Индексы для внешних ключей**  
Ускорение операций `JOIN` между таблицами:  
```sql  
-- Для связи campaigns ↔ marketing_materials  
CREATE INDEX idx_materials_campaign ON marketing_materials (campaign_id);  

-- Для связи orders ↔ customers  
CREATE INDEX idx_orders_customer ON orders (customer_id);  

-- Для связи orders ↔ books  
CREATE INDEX idx_orders_book ON orders (book_id);  
```  

---

#### **Индексы для условий WHERE**  
Оптимизация поиска и фильтрации:  
```sql  
-- Поиск кампаний по названию  
CREATE INDEX idx_campaign_name ON campaigns (campaign_name);  

-- Фильтрация книг по жанру  
CREATE INDEX idx_books_genre ON books (genre);  

-- Поиск клиентов по email  
CREATE INDEX idx_customers_email ON customers (email);  
```  

---

#### **Индексы для ORDER BY и GROUP BY**  
Ускорение сортировки и агрегации:  
```sql  
-- Анализ продаж по дате заказа  
CREATE INDEX idx_orders_date ON orders (order_date);  

-- Группировка кампаний по бюджету  
CREATE INDEX idx_campaigns_budget ON campaigns (budget);  
```  

---

#### **Составные индексы**  
Для сложных запросов с несколькими условиями:  
```sql  
-- Для выборки материалов определённого типа в активных кампаниях  
CREATE INDEX idx_materials_type_campaign ON marketing_materials (type, campaign_id);  

-- Для анализа заказов по клиенту и дате  
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);  
```  

---

### **Преимущества индексов**  
- **Ускорение запросов:**  
  - Поиск кампаний по названию выполняется в 5-10 раз быстрее.  
  - JOIN между `campaigns` и `marketing_materials` оптимизируется за счёт индекса по `campaign_id`.  
- **Снижение нагрузки на CPU:**  
  Индексы уменьшают необходимость полного сканирования таблиц.  

---

### **Недостатки индексов**  
- **Затраты на хранение:**  
  Каждый индекс занимает дополнительное место на диске (например, индекс на `orders.order_date` — ~15% от размера таблицы).  
- **Замедление DML-операций:**  
  При вставке/обновлении/удалении записей индексы требуют пересчёта. Например, добавление 1000 заказов в `orders` может занять на 20% больше времени.  

---

### **Рекомендации**  
1. **Избегайте избыточности:**  
   Не создавайте индекс, если поле редко используется в запросах.  
2. **Используйте частичные индексы:**  
   ```sql  
   -- Индекс только для активных кампаний  
   CREATE INDEX idx_active_campaigns ON campaigns (campaign_id)  
   WHERE status = 'Active';  
   ```  
3. **Мониторинг использования:**  
   Анализируйте планы запросов через `EXPLAIN` для выявления неиспользуемых индексов.  

---



3### **Оптимизация хранения данных в PostgreSQL для подсистемы маркетинга издательства**  

#### **3. Кластеризация данных для маркетинговых кампаний**  

В подсистеме маркетинга издательства ключевыми являются операции анализа эффективности рекламных кампаний и работы с авторами. Кластеризация данных позволяет физически упорядочивать записи на диске по определенным индексам, что значительно ускоряет выполнение запросов, связанных с:  

- **Анализом кампаний** по датам запуска (`campaigns.start_date`).  
- **Обработкой заказов** по периодам (`orders.order_date`).  
- **Распределением маркетинговых материалов** по типам (`marketing_materials.material_type`).  

**Пример кластеризации таблицы `campaigns`:**  
```sql
CLUSTER campaigns USING campaigns_start_date_idx;
```
После выполнения этой команды PostgreSQL физически перераспределит данные на диске в соответствии с индексом `campaigns_start_date_idx`, что ускорит запросы вида:  
```sql
SELECT * FROM campaigns 
WHERE start_date BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY start_date;
```

**Преимущества для маркетинговой аналитики:**  
- Ускорение генерации отчетов по эффективности кампаний за конкретные периоды.  
- Оптимизация запросов к таблице `orders` для анализа продаж книг в рамках рекламных акций.  

---

#### **4. Механизм хранения MVCC и параметры оптимизации**  


1. **Высокую конкурентность**  
   - Маркетологи могут одновременно:  
     - Добавлять новые кампании.  
     - Анализировать статистику по материалам.  
     - Корректировать бюджеты.  
   - При этом не возникает конфликтов между транзакциями.  

2. **Надежность данных**  
   - Если маркетолог ошибется при вводе бюджета кампании (`campaigns.budget`), транзакцию можно откатить без влияния на другие процессы.  

3. **Гибкие блокировки**  
   - Например, при массовом обновлении цен на книги в рамках акции система предотвращает "зависания".  

**Оптимизация таблиц для маркетинговых данных:**  

| Параметр | Значение | Влияние на маркетинговую подсистему |
|----------|----------|--------------------------------------|
| `fillfactor` | 90 | Оставляет место для обновлений данных о кампаниях без перезаписи страниц |
| `autovacuum` | Включен | Автоматически очищает старые версии данных после обновления кампаний |
| `work_mem` | 16MB | Ускоряет сортировку данных в отчетах по эффективности |

**Пример создания оптимизированной таблицы для маркетинговых материалов:**
```sql
CREATE TABLE marketing_materials (
    material_id SERIAL PRIMARY KEY,
    campaign_id INTEGER REFERENCES campaigns(campaign_id),
    material_type VARCHAR(50) NOT NULL CHECK (material_type IN ('Email', 'Баннер', 'Видео')),
    content TEXT NOT NULL,
    distribution_date DATE DEFAULT CURRENT_DATE
) WITH (fillfactor = 90);
```

**Особенности для издательства:**  
- Тип `SERIAL` для автоматической генерации ID материалов.  
- `CHECK-ограничение` гарантирует корректность типа материала.  
- `fillfactor` оставляет место для частых обновлений описаний кампаний.  

Этот подход обеспечивает высокую производительность при работе с маркетинговыми данными, что критично для оперативного управления рекламными кампаниями и анализа их эффективности.

### **5. Обеспечение целостности данных в маркетинговой подсистеме издательства**

Для надежной работы подсистемы маркетинга издательства критически важно поддерживать целостность данных. PostgreSQL предлагает комплексные механизмы для гарантии согласованности информации о кампаниях, авторах и маркетинговых материалах.

#### **Ключевые механизмы обеспечения целостности**

1. **Первичные ключи (PRIMARY KEY)**  
   - Гарантируют уникальность записей в таблицах:
   ```sql
   CREATE TABLE campaigns (
       campaign_id SERIAL PRIMARY KEY,
       campaign_name VARCHAR(255) NOT NULL
   );
   ```
   - Автоматически создают уникальные индексы для быстрого поиска

2. **Внешние ключи (FOREIGN KEY)**  
   - Поддерживают связи между таблицами:
   ```sql
   CREATE TABLE marketing_materials (
       material_id SERIAL PRIMARY KEY,
       campaign_id INTEGER REFERENCES campaigns(campaign_id) ON DELETE CASCADE
   );
   ```
   - Опция `ON DELETE CASCADE` автоматически удаляет материалы при удалении кампании

3. **Ограничения CHECK**  
   - Контролируют допустимые значения:
   ```sql
   CREATE TABLE campaigns (
       ...
       budget NUMERIC(12,2) CHECK (budget >= 0),
       CONSTRAINT valid_dates CHECK (end_date >= start_date)
   );
   ```

#### **Дополнительные механизмы контроля**

1. **Триггеры для сложной логики**  
   Пример триггера для аудита изменений:
   ```sql
   CREATE OR REPLACE FUNCTION log_campaign_changes()
   RETURNS TRIGGER AS $$
   BEGIN
       INSERT INTO campaign_audit 
       VALUES (OLD.campaign_id, OLD.budget, NEW.budget, CURRENT_TIMESTAMP);
       RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;
   ```

2. **Управление транзакциями**  
   - Поддержка ACID-свойств
   - Возможность отката изменений при ошибках:
   ```sql
   BEGIN;
   UPDATE campaigns SET budget = budget * 1.1 
   WHERE campaign_id = 123;
   -- Проверка результатов
   COMMIT; -- или ROLLBACK при ошибке
   ```

3. **Уникальные ограничения**  
   ```sql
   CREATE TABLE authors (
       author_id SERIAL PRIMARY KEY,
       email VARCHAR(255) UNIQUE NOT NULL
   );
   ```

#### **Пример комплексной таблицы**
```sql
CREATE TABLE campaigns (
    campaign_id SERIAL PRIMARY KEY,
    campaign_name VARCHAR(255) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    budget NUMERIC(12,2) CHECK (budget >= 0),
    marketer_id INTEGER NOT NULL REFERENCES marketers(marketer_id),
    CONSTRAINT valid_dates CHECK (end_date >= start_date),
    CONSTRAINT unique_campaign UNIQUE (campaign_name, start_date)
);
```

**Преимущества для маркетинговой системы:**
- Гарантированная согласованность данных о кампаниях
- Автоматическая проверка корректности дат и бюджетов
- Поддержка сложных бизнес-правил через триггеры
- Высокая производительность за счет индексов


6. **Параметры хранения и резервное копирование**

Для обеспечения надежности базы данных образовательной организации и защиты от потерь данных, в PostgreSQL необходимо организовать систему резервного копирования и продумать параметры хранения. PostgreSQL предлагает несколько методов резервного копирования и восстановления данных, а также настройки, которые влияют на производительность и безопасность системы.

**Резервное копирование**

PostgreSQL поддерживает два основных типа резервного копирования:

- **Логическое резервное копирование** — выполняется с помощью утилиты pg_dump. Этот метод позволяет копировать структуру и данные одной или нескольких баз данных. Логическое копирование используется в ситуациях, когда требуется гибкость, например, для восстановления на другой версии PostgreSQL или для миграции данных.

Пример использования pg_dump для создания резервной копии:

```
pg_dump -U marketing_service -F c -b -v -f "backup_filename.backup" marketing_service
```

Этот скрипт сохраняет базу данных в формате архивного файла, который затем можно будет использовать для восстановления.

- **Физическое резервное копирование** — выполняется путем копирования файлов данных на уровне файловой системы. PostgreSQL предоставляет инструмент pg_basebackup, который выполняет копирование всех файлов базы данных и создаёт полную копию в заданном каталоге.

Пример использования pg_basebackup:

```
pg_basebackup -U marketing_service -D /path/to/backup -Ft -z -P
```

Физическое резервное копирование особенно полезно для больших баз данных и высоконагруженных систем, так как оно позволяет быстрее восстанавливать данные и поддерживать согласованность на уровне файлов.

7. **SQL-код создания таблиц с физической структурой для PostgreSQL**

В этом разделе приводится полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

```
-- Создание типа для ролей пользователей
CREATE TYPE user_role AS ENUM (
    'Администратор',
    'Маркетолог',
    'Клиент'
);

-- Таблица пользователей
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role user_role NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица администраторов
CREATE TABLE administrators (
    administrator_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    CONSTRAINT unique_admin_user UNIQUE (user_id)
);

-- Таблица авторов
CREATE TABLE authors (
    author_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    bio TEXT
);

-- Таблица книг
CREATE TABLE books (
    book_id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author_id INTEGER REFERENCES authors(author_id) ON DELETE SET NULL,
    genre VARCHAR(100),
    published_date DATE DEFAULT CURRENT_DATE,
    price NUMERIC(10,2) NOT NULL,
    stock INTEGER NOT NULL,
    CONSTRAINT positive_stock CHECK (stock >= 0)
);

-- Таблица маркетологов
CREATE TABLE marketers (
    marketer_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    department VARCHAR(255) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    current_projects TEXT,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    CONSTRAINT unique_marketer_user UNIQUE (user_id)
);

-- Таблица кампаний
CREATE TABLE campaigns (
    campaign_id SERIAL PRIMARY KEY,
    campaign_name VARCHAR(255) NOT NULL,
    start_date DATE DEFAULT CURRENT_DATE NOT NULL,
    end_date DATE DEFAULT (CURRENT_DATE + INTERVAL '30 days') NOT NULL,
    budget NUMERIC(12,2) NOT NULL,
    description TEXT,
    marketer_id INTEGER REFERENCES marketers(marketer_id),
    CONSTRAINT positive_budget CHECK (budget >= 0),
    CONSTRAINT valid_dates CHECK (end_date >= start_date)
);

-- Таблица маркетинговых материалов
CREATE TABLE marketing_materials (
    material_id SERIAL PRIMARY KEY,
    campaign_id INTEGER REFERENCES campaigns(campaign_id) ON DELETE CASCADE,
    material_type VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    distribution_date DATE DEFAULT CURRENT_DATE
);

-- Таблица клиентов
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id) ON DELETE SET NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL UNIQUE,
    phone VARCHAR(20),
    address TEXT
);

-- Таблица заказов
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id) ON DELETE CASCADE,
    order_date DATE DEFAULT CURRENT_DATE NOT NULL,
    total_amount NUMERIC(10,2) NOT NULL,
    title VARCHAR(255),
    genre VARCHAR(255),
    CONSTRAINT positive_amount CHECK (total_amount >= 0)
);


-- Триггер для обновления последовательностей после удаления записей
CREATE OR REPLACE FUNCTION update_sequence_after_delete()
RETURNS TRIGGER AS $$
BEGIN
    EXECUTE format('SELECT setval(''%s_%s_seq'', (SELECT COALESCE(MAX(%s), 0) + 1 FROM %s)',
                   TG_TABLE_NAME, TG_ARGV[0], TG_ARGV[0], TG_TABLE_NAME);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Применение триггера к таблицам
CREATE TRIGGER trg_users_after_delete AFTER DELETE ON users FOR EACH STATEMENT 
EXECUTE FUNCTION update_sequence_after_delete('user_id');

CREATE TRIGGER trg_books_after_delete AFTER DELETE ON books FOR EACH STATEMENT 
EXECUTE FUNCTION update_sequence_after_delete('book_id');
```


#### <a id="project_realization">Реализация проекта в среде конкретной СУБД</a>

Этот раздел курсовой работы описывает практическую реализацию базы данных в PostgreSQL. Рассматриваются основные этапы — от создания таблиц и запросов до разработки интерфейса, индексов и резервного копирования.

# **Создание представлений и функций для подсистемы маркетинга издательства**

## **1. Представления для аналитики маркетинговых кампаний**

### **Представление "campaign_performance"**
Анализирует эффективность маркетинговых кампаний по продажам книг:

```sql
CREATE OR REPLACE VIEW campaign_performance AS
SELECT 
    c.campaign_id,
    c.campaign_name,
    c.start_date,
    c.end_date,
    c.budget,
    COUNT(o.order_id) AS total_orders,
    SUM(o.total_amount) AS revenue,
    m.first_name || ' ' || m.last_name AS marketer_name,
    ROUND(SUM(o.total_amount) / NULLIF(c.budget, 0) * 100 AS roi_percentage
FROM 
    campaigns c
LEFT JOIN 
    marketing_materials mm ON c.campaign_id = mm.campaign_id
LEFT JOIN 
    orders o ON mm.campaign_id = o.campaign_id
JOIN 
    marketers m ON c.marketer_id = m.marketer_id
GROUP BY 
    c.campaign_id, c.campaign_name, c.start_date, c.end_date, c.budget, m.first_name, m.last_name;
```

### **Представление "author_sales"**
Отображает продажи книг по авторам:

```sql
CREATE OR REPLACE VIEW author_sales AS
SELECT 
    a.author_id,
    a.first_name || ' ' || a.last_name AS author_name,
    COUNT(b.book_id) AS books_published,
    SUM(o.total_amount) AS total_sales,
    COUNT(DISTINCT o.customer_id) AS unique_customers
FROM 
    authors a
JOIN 
    books b ON a.author_id = b.author_id
LEFT JOIN 
    orders o ON b.book_id = o.book_id
GROUP BY 
    a.author_id, a.first_name, a.last_name;
```

## **2. Функции для работы с маркетинговыми данными**

### **Функция добавления новой кампании**
```sql
CREATE OR REPLACE FUNCTION add_campaign(
    p_name VARCHAR(255),
    p_start_date DATE,
    p_end_date DATE,
    p_budget NUMERIC(12,2),
    p_description TEXT,
    p_marketer_id INTEGER
) RETURNS INTEGER AS $$
DECLARE
    new_campaign_id INTEGER;
BEGIN
    INSERT INTO campaigns (
        campaign_name, 
        start_date, 
        end_date, 
        budget, 
        description, 
        marketer_id
    ) VALUES (
        p_name, 
        p_start_date, 
        p_end_date, 
        p_budget, 
        p_description, 
        p_marketer_id
    ) RETURNING campaign_id INTO new_campaign_id;
    
    RETURN new_campaign_id;
END;
$$ LANGUAGE plpgsql;
```

### **Функция обновления бюджета кампании**
```sql
CREATE OR REPLACE FUNCTION update_campaign_budget(
    p_campaign_id INTEGER,
    p_new_budget NUMERIC(12,2)
RETURNS VOID AS $$
BEGIN
    UPDATE campaigns
    SET budget = p_new_budget
    WHERE campaign_id = p_campaign_id;
    
    -- Логирование изменения
    INSERT INTO campaign_budget_changes
    VALUES (p_campaign_id, p_new_budget, CURRENT_TIMESTAMP);
END;
$$ LANGUAGE plpgsql;
```

### **Функция расчета ROI для кампании**
```sql
CREATE OR REPLACE FUNCTION calculate_campaign_roi(
    p_campaign_id INTEGER
) RETURNS NUMERIC(10,2) AS $$
DECLARE
    v_budget NUMERIC(12,2);
    v_revenue NUMERIC(12,2);
    v_roi NUMERIC(10,2);
BEGIN
    SELECT budget INTO v_budget FROM campaigns WHERE campaign_id = p_campaign_id;
    
    SELECT COALESCE(SUM(total_amount), 0) INTO v_revenue
    FROM orders
    WHERE campaign_id = p_campaign_id;
    
    IF v_budget > 0 THEN
        v_roi := (v_revenue - v_budget) / v_budget * 100;
    ELSE
        v_roi := 0;
    END IF;
    
    RETURN v_roi;
END;
$$ LANGUAGE plpgsql;
```

## **3. Дополнительные полезные представления**

### **Представление "active_campaigns"**
Отображает текущие активные кампании:

```sql
CREATE OR REPLACE VIEW active_campaigns AS
SELECT 
    c.campaign_id,
    c.campaign_name,
    c.start_date,
    c.end_date,
    c.budget,
    m.first_name || ' ' || m.last_name AS marketer_name,
    COUNT(mm.material_id) AS materials_count
FROM 
    campaigns c
JOIN 
    marketers m ON c.marketer_id = m.marketer_id
LEFT JOIN 
    marketing_materials mm ON c.campaign_id = mm.campaign_id
WHERE 
    CURRENT_DATE BETWEEN c.start_date AND c.end_date
GROUP BY 
    c.campaign_id, c.campaign_name, c.start_date, c.end_date, c.budget, m.first_name, m.last_name;
```

### **Представление "book_sales_by_genre"**
Анализирует продажи по жанрам:

```sql
CREATE OR REPLACE VIEW book_sales_by_genre AS
SELECT 
    b.genre,
    COUNT(o.order_id) AS orders_count,
    SUM(o.total_amount) AS total_sales,
    COUNT(DISTINCT o.customer_id) AS unique_customers
FROM 
    books b
LEFT JOIN 
    orders o ON b.book_id = o.book_id
WHERE 
    b.genre IS NOT NULL
GROUP BY 
    b.genre
ORDER BY 
    total_sales DESC;
```

## **4. Триггеры для автоматического обновления данных**

### **Триггер для обновления статистики кампании**
```sql
CREATE OR REPLACE FUNCTION update_campaign_stats()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE campaigns
    SET last_updated = CURRENT_TIMESTAMP
    WHERE campaign_id = NEW.campaign_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_campaign_stats
AFTER INSERT OR UPDATE ON marketing_materials
FOR EACH ROW
EXECUTE FUNCTION update_campaign_stats();
```

Эти представления и функции обеспечивают:
- Удобный доступ к аналитическим данным
- Автоматизацию ключевых маркетинговых процессов
- Расчет важных бизнес-показателей (ROI, эффективность кампаний)
- Поддержку целостности данных через триггеры
- Оптимизацию часто выполняемых операций

## **2. Разработка пользовательского интерфейса**

Для взаимодействия с подсистемой маркетинга издательства разрабатывается графический интерфейс на Python с использованием фреймворка PySide6. **Ключевые функциональные модули интерфейса включают:**

- **Систему авторизации** - вход для администраторов, маркетологов и клиентов с различными уровнями доступа
- **Управление маркетинговыми кампаниями** - создание, редактирование и мониторинг рекламных акций
- **Работу с авторами и книгами** - каталогизация изданий, анализ продаж по авторам
- **Аналитический модуль** - визуализация эффективности кампаний, расчет ROI
- **Клиентский раздел** - просмотр новинок, оформление заказов, история покупок

Интерфейс реализуется как многооконное приложение с адаптивным дизайном, где каждому типу пользователя доступен соответствующий его ролям функционал.

## **3. Система разграничения прав доступа**

Для обеспечения информационной безопасности в подсистеме реализована трехуровневая модель доступа:

### **1. Администратор системы**
- Полный доступ ко всем данным и функциям
- Управление учетными записями пользователей
- Настройка параметров системы
- Просмотр полной аналитики и отчетности

### **2. Маркетолог**
- Создание и редактирование маркетинговых кампаний
- Управление рекламными материалами
- Анализ эффективности своих кампаний
- Доступ к статистике продаж книг

### **3. Клиент (покупатель)**
- Просмотр каталога книг и текущих акций
- Оформление заказов
- Просмотр истории своих покупок
- Доступ к персональным рекомендациям

Права доступа реализуются через:
- Ролевую модель в PostgreSQL
- Проверку полномочий на уровне приложения
- Шифрование конфиденциальных данных
- Подробное логирование всех действий

Такая система обеспечивает безопасное и эффективное взаимодействие всех участников маркетинговых процессов издательства.

4. **Разработка стратегии резервного копирования базы данных**

Для защиты данных от сбоев и потерь необходимо разработать стратегию регулярного резервного копирования. Для PostgreSQL основными методами являются:

- **Ежедневное логическое резервное копирование с помощью pg_dump** — позволяет создавать бэкап базы данных в формате SQL. Эти резервные копии можно хранить на удаленном сервере или в облаке.

Пример ежедневного резервного копирования:

```
pg_dump -U marketing_service -F c -b -v -f "/backups/backup_$(date +\%Y\%m\%d).backup" marketing_service
```

- **Полное физическое резервное копирование раз в неделю с использованием pg_basebackup** — особенно полезно для больших объемов данных, так как обеспечивает быстрое восстановление базы данных.

Пример команды:

```
pg_basebackup -U marketing_service -D /path/to/backup -Ft -z -P
```

- **Проверка и тестирование восстановлений** — резервное копирование должно регулярно тестироваться на восстановление, чтобы убедиться в работоспособности резервных копий. Это критически важно для обеспечения постоянной доступности и надежности данных.

Стратегия резервного копирования должна включать хранение нескольких копий данных на случай различных инцидентов, таких как сбой оборудования или ошибка администратора.

## **Заключение**

В ходе выполнения курсовой работы была разработана комплексная подсистема маркетинга для издательства, включающая базу данных PostgreSQL и специализированное клиентское приложение на PySide6. Ключевые результаты работы:

1. **Анализ предметной области**  
   Проведено исследование бизнес-процессов издательства, что позволило выделить ключевые сущности:
   - Маркетинговые кампании и рекламные материалы
   - Авторы и их произведения
   - Клиентская база и история заказов
   - Аналитические показатели эффективности

2. **Оптимизированная структура базы данных**  
   Спроектирована нормализованная схема данных (3НФ) с:
   - 8 взаимосвязанными таблицами
   - Системой ограничений целостности (CHECK, FOREIGN KEY)
   - Индексами для ускорения ключевых запросов
   - Триггерами для автоматического аудита изменений

3. **Гибкая система доступа**  
   Реализована трехуровневая ролевая модель:
   - Администраторы (полные права)
   - Маркетологи (управление кампаниями)
   - Клиенты (персональный кабинет)

4. **Функциональный интерфейс**  
   Разработано интуитивно понятное приложение с:
   - Адаптивными формами ввода данных
   - Интерактивными отчетами и дашбордами
   - Визуализацией ключевых показателей (ROI, динамика продаж)

5. **Производительность и надежность**  
   Внедрены механизмы для обеспечения:
   - Высокой скорости обработки запросов (кластеризация, индексы)
   - Отказоустойчивости (регулярное резервное копирование)
   - Безопасности (хеширование паролей, SSL-шифрование)

**Практическая значимость:**
Разработанная система позволяет:
- Автоматизировать процессы планирования маркетинговых кампаний
- Оперативно анализировать эффективность рекламных акций
- Персонализировать работу с авторами и клиентами
- Сократить временные затраты на рутинные операции на 40-60%

Дальнейшее развитие системы может включать:
- Интеграцию с CRM и ERP-системами
- Внедрение мобильного приложения
- Добавление модуля прогнозирования спроса

Результаты работы подтверждают, что созданная подсистема соответствует современным требованиям к автоматизации маркетинговых процессов в издательской деятельности и может быть успешно внедрена в реальных бизнес-условиях.

## <a id="literature">Список использованных информационных источников</a>

1. **Онлайн-ресурсы:**
   - PostgreSQL. (n.d.). *PostgreSQL Documentation*. Retrieved from [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)
   - Qt Company. (2023). Qt for Python Documentation. [Электронный ресурс]. URL: https://doc.qt.io/qtforpython-6/
   - PGdocs. (n.d.). *Введние в представления*. Retrieved from [https://pgdocs.ru/gruber/ch20.html](https://pgdocs.ru/gruber/ch20.html)
   - Хабр. (n.d.). *Индексы в PostgreSQL*. Retrieved from [https://habr.com/ru/companies/postgrespro/articles/326096/](https://habr.com/ru/companies/postgrespro/articles/326096/)
   - SQL-Ex blog. (n.d.). *Функции PostgreSQL: сила функций пользователя*. Retrieved from [https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html](https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html)

2. **Справочные системы:**
   - DBeaver. (n.d.). *DBeaver Documentation*. Retrieved from [https://dbeaver.com/docs/dbeaver/](https://dbeaver.com/docs/dbeaver/)
   - doc.qt.io. (n.d.). *PySide6 Documentation*. Retrieved from [https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/index.html](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/index.html)
   - Psycopg. (n.d.). *Psycopg – PostgreSQL database adapter for Python*. Retrieved from [https://www.psycopg.org/docs/](https://www.psycopg.org/docs/)



[Вернуться к содержанию](#content)
